"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Either_1 = require("fp-ts/lib/Either");
const types_1 = require("../types");
const errors_1 = require("./errors");
const matchBaseUrl_1 = require("./matchBaseUrl");
const matchPath_1 = require("./matchPath");
const types_2 = require("./types");
const route = ({ resources, input }) => {
    const { path: requestPath, baseUrl: requestBaseUrl } = input.url;
    if (!resources.length) {
        return Either_1.left(types_1.ProblemJsonError.fromTemplate(errors_1.NO_RESOURCE_PROVIDED_ERROR, `The current document does not have any resource to match with.`));
    }
    let matches = resources.map(resource => {
        const pathMatch = matchPath_1.matchPath(requestPath, resource.path);
        if (pathMatch === types_2.MatchType.NOMATCH)
            return {
                pathMatch,
                methodMatch: types_2.MatchType.NOMATCH,
                resource,
            };
        const methodMatch = matchByMethod(input, resource) ? types_2.MatchType.CONCRETE : types_2.MatchType.NOMATCH;
        if (methodMatch === types_2.MatchType.NOMATCH) {
            return {
                pathMatch,
                methodMatch,
                resource,
            };
        }
        const { servers = [] } = resource;
        if (requestBaseUrl && servers.length > 0) {
            const serverMatch = matchServer(servers, requestBaseUrl);
            return {
                pathMatch,
                methodMatch,
                serverMatch,
                resource,
            };
        }
        return {
            pathMatch,
            methodMatch,
            serverMatch: null,
            resource,
        };
    });
    matches = matches.filter(match => match.pathMatch !== types_2.MatchType.NOMATCH);
    if (!matches.length) {
        return Either_1.left(types_1.ProblemJsonError.fromTemplate(errors_1.NO_PATH_MATCHED_ERROR, `The route ${requestPath} hasn't been found in the specification file`));
    }
    matches = matches.filter(match => match.methodMatch !== types_2.MatchType.NOMATCH);
    if (!matches.length) {
        return Either_1.left(types_1.ProblemJsonError.fromTemplate(errors_1.NO_METHOD_MATCHED_ERROR, `The route ${requestPath} has been matched, but it does not have "${input.method}" method defined`));
    }
    if (requestBaseUrl) {
        if (resources.every(resource => !resource.servers || resource.servers.length === 0)) {
            return Either_1.left(types_1.ProblemJsonError.fromTemplate(errors_1.NO_SERVER_CONFIGURATION_PROVIDED_ERROR, `No server configuration has been provided, although ${requestBaseUrl} is set as server url`));
        }
        matches = matches.filter(match => !!match.serverMatch && match.serverMatch !== types_2.MatchType.NOMATCH);
        if (!matches.length) {
            return Either_1.left(types_1.ProblemJsonError.fromTemplate(errors_1.NO_SERVER_MATCHED_ERROR, `The server url ${requestBaseUrl} hasn't been matched with any of the provided servers`));
        }
    }
    return Either_1.right(disambiguateMatches(matches));
};
function matchServer(servers, requestBaseUrl) {
    const serverMatches = servers
        .map(server => matchBaseUrl_1.matchBaseUrl(server, requestBaseUrl))
        .filter(match => match !== types_2.MatchType.NOMATCH);
    return disambiguateServers(serverMatches);
}
function matchByMethod(request, operation) {
    return operation.method.toLowerCase() === request.method.toLowerCase();
}
function disambiguateMatches(matches) {
    const matchResult = matches.find(match => areServerAndPath(match, types_2.MatchType.CONCRETE, types_2.MatchType.CONCRETE)) ||
        matches.find(match => areServerAndPath(match, types_2.MatchType.TEMPLATED, types_2.MatchType.CONCRETE)) ||
        matches.find(match => areServerAndPath(match, types_2.MatchType.CONCRETE, types_2.MatchType.TEMPLATED)) ||
        matches[0];
    return matchResult.resource;
}
function areServerAndPath(match, serverType, pathType) {
    const serverMatch = match.serverMatch;
    if (serverMatch === null) {
        return match.pathMatch === pathType;
    }
    return serverMatch === serverType && match.pathMatch === pathType;
}
function disambiguateServers(serverMatches) {
    const concreteMatch = serverMatches.find(serverMatch => serverMatch === types_2.MatchType.CONCRETE);
    return concreteMatch || serverMatches[0] || types_2.MatchType.NOMATCH;
}
exports.default = route;

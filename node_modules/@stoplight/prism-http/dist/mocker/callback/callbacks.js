"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const runtimeExpression_1 = require("../../utils/runtimeExpression");
const node_fetch_1 = require("node-fetch");
const Option = require("fp-ts/lib/Option");
const Either = require("fp-ts/lib/Either");
const Array_1 = require("fp-ts/lib/Array");
const TaskEither = require("fp-ts/lib/TaskEither");
const Array_2 = require("fp-ts/lib/Array");
const pipeable_1 = require("fp-ts/lib/pipeable");
const HttpParamGenerator_1 = require("../generator/HttpParamGenerator");
const validator_1 = require("../../validator");
const parseResponse_1 = require("../../utils/parseResponse");
const withLogger_1 = require("../../withLogger");
const logger_1 = require("../../utils/logger");
function runCallback({ callback, request, response, }) {
    return withLogger_1.default(logger => {
        const { url, requestData } = assembleRequest({ resource: callback, request, response });
        const logViolation = logger_1.violationLogger(logger);
        logger.info({ name: 'CALLBACK' }, `${callback.callbackName}: Making request to ${url}...`);
        return pipeable_1.pipe(TaskEither.tryCatch(() => node_fetch_1.default(url, requestData), Either.toError), TaskEither.chain(parseResponse_1.parseResponse), TaskEither.mapLeft(error => logger.error({ name: 'CALLBACK' }, `${callback.callbackName}: Request failed: ${error.message}`)), TaskEither.chain(element => {
            logger.info({ name: 'CALLBACK' }, `${callback.callbackName}: Request finished`);
            return pipeable_1.pipe(validator_1.validateOutput({ resource: callback, element }), Either.mapLeft(violations => {
                pipeable_1.pipe(violations, Array_1.map(logViolation));
            }), TaskEither.fromEither);
        }));
    });
}
exports.runCallback = runCallback;
function assembleRequest({ resource, request, response, }) {
    const bodyAndMediaType = Option.toUndefined(assembleBody(resource.request));
    return {
        url: runtimeExpression_1.resolveRuntimeExpressions(resource.path, request, response),
        requestData: {
            headers: Option.toUndefined(assembleHeaders(resource.request, bodyAndMediaType && bodyAndMediaType.mediaType)),
            body: bodyAndMediaType && bodyAndMediaType.body,
            method: resource.method,
        },
    };
}
function assembleBody(request) {
    return pipeable_1.pipe(Option.fromNullable(request), Option.mapNullable(request => request.body), Option.mapNullable(body => body.contents), Option.chain(Array_2.head), Option.chain(param => pipeable_1.pipe(param, HttpParamGenerator_1.generate, Option.map(body => ({ body, mediaType: param.mediaType })))), Option.chain(({ body, mediaType }) => pipeable_1.pipe(Either.stringifyJSON(body, () => undefined), Either.map(body => ({ body, mediaType })), Option.fromEither)));
}
function assembleHeaders(request, bodyMediaType) {
    return pipeable_1.pipe(Option.fromNullable(request), Option.mapNullable(request => request.headers), Option.map(params => pipeable_1.pipe(params, Array_1.reduce({}, (headers, param) => pipeable_1.pipe(param, HttpParamGenerator_1.generate, Option.fold(() => headers, value => ({ ...headers, [param.name]: value })))))), Option.reduce(pipeable_1.pipe(Option.fromNullable(bodyMediaType), Option.map(mediaType => ({ 'content-type': mediaType }))), (mediaTypeHeader, headers) => ({ ...headers, ...mediaTypeHeader })));
}

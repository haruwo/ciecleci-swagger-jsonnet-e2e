"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("@stoplight/types");
const caseless = require("caseless");
const Either = require("fp-ts/lib/Either");
const pipeable_1 = require("fp-ts/lib/pipeable");
const Reader = require("fp-ts/lib/Reader");
const Option = require("fp-ts/lib/Option");
const ReaderEither = require("fp-ts/lib/ReaderEither");
const Array_1 = require("fp-ts/lib/Array");
const lodash_1 = require("lodash");
const typeIs = require("type-is");
const types_2 = require("../types");
const withLogger_1 = require("../withLogger");
const errors_1 = require("./errors");
const JSONSchema_1 = require("./generator/JSONSchema");
const NegotiatorHelpers_1 = require("./negotiator/NegotiatorHelpers");
const callbacks_1 = require("./callback/callbacks");
const body_1 = require("../validator/validators/body");
const mock = ({ resource, input, config, }) => {
    const payloadGenerator = config.dynamic ? JSONSchema_1.generate : JSONSchema_1.generateStatic;
    return pipeable_1.pipe(withLogger_1.default(logger => {
        const acceptMediaType = input.data.headers && caseless(input.data.headers).get('accept');
        if (!config.mediaTypes && acceptMediaType) {
            logger.info(`Request contains an accept header: ${acceptMediaType}`);
            config.mediaTypes = acceptMediaType.split(',');
        }
        return config;
    }), Reader.chain(mockConfig => negotiateResponse(mockConfig, input, resource)), Reader.chain(result => assembleResponse(result, payloadGenerator)), Reader.chain(response => withLogger_1.default(logger => pipeable_1.pipe(response, Either.map(response => runCallbacks({ resource, request: input.data, response })(logger)), Either.chain(() => response)))));
};
function runCallbacks({ resource, request, response, }) {
    return withLogger_1.default(logger => pipeable_1.pipe(Option.fromNullable(resource.callbacks), Option.map(callbacks => pipeable_1.pipe(callbacks, Array_1.map(callback => callbacks_1.runCallback({ callback, request: parseBodyIfUrlEncoded(request, resource), response })(logger)())))));
}
function parseBodyIfUrlEncoded(request, resource) {
    const mediaType = caseless(request.headers || {}).get('content-type');
    if (!mediaType)
        return request;
    if (!typeIs.is(mediaType, ['application/x-www-form-urlencoded']))
        return request;
    const specs = pipeable_1.pipe(Option.fromNullable(resource.request), Option.mapNullable(request => request.body), Option.mapNullable(body => body.contents), Option.getOrElse(() => []));
    const encodedUriParams = body_1.splitUriParams(request.body);
    if (specs.length < 1) {
        return Object.assign(request, { body: encodedUriParams });
    }
    const content = pipeable_1.pipe(Option.fromNullable(mediaType), Option.chain(mediaType => body_1.findContentByMediaTypeOrFirst(specs, mediaType)), Option.map(({ content }) => content), Option.getOrElse(() => specs[0] || {}));
    const encodings = lodash_1.get(content, 'encodings', []);
    if (!content.schema)
        return Object.assign(request, { body: encodedUriParams });
    return Object.assign(request, {
        body: body_1.deserializeFormBody(content.schema, encodings, body_1.decodeUriEntities(encodedUriParams)),
    });
}
function handleInputValidation(input, resource) {
    const securityValidation = input.validations.find(validation => validation.code === 401);
    return pipeable_1.pipe(withLogger_1.default(logger => logger.warn({ name: 'VALIDATOR' }, 'Request did not pass the validation rules')), Reader.chain(() => pipeable_1.pipe(NegotiatorHelpers_1.default.negotiateOptionsForInvalidRequest(resource.responses, securityValidation ? ['401'] : ['422', '400']), ReaderEither.mapLeft(() => securityValidation
        ? types_2.ProblemJsonError.fromTemplate(errors_1.UNAUTHORIZED, '', securityValidation.tags && securityValidation.tags.length
            ? {
                headers: { 'WWW-Authenticate': securityValidation.tags.join(',') },
            }
            : undefined)
        : types_2.ProblemJsonError.fromTemplate(errors_1.UNPROCESSABLE_ENTITY, 'Your request is not valid and no HTTP validation response was found in the spec, so Prism is generating this error for you.', {
            validation: input.validations.map(detail => ({
                location: detail.path,
                severity: types_1.DiagnosticSeverity[detail.severity],
                code: detail.code,
                message: detail.message,
            })),
        })))));
}
function negotiateResponse(mockConfig, input, resource) {
    const { [types_1.DiagnosticSeverity.Error]: errors, [types_1.DiagnosticSeverity.Warning]: warnings } = lodash_1.groupBy(input.validations, validation => validation.severity);
    if (errors) {
        return handleInputValidation(input, resource);
    }
    else {
        return pipeable_1.pipe(withLogger_1.default(logger => {
            warnings && warnings.forEach(warn => logger.warn({ name: 'VALIDATOR' }, warn.message));
            return logger.success({ name: 'VALIDATOR' }, 'The request passed the validation rules. Looking for the best response');
        }), Reader.chain(() => NegotiatorHelpers_1.default.negotiateOptionsForValidRequest(resource, mockConfig)));
    }
}
function assembleResponse(result, payloadGenerator) {
    return withLogger_1.default(logger => pipeable_1.pipe(result, Either.map(negotiationResult => {
        const mockedBody = computeBody(negotiationResult, payloadGenerator);
        const mockedHeaders = computeMockedHeaders(negotiationResult.headers || [], payloadGenerator);
        const response = {
            statusCode: parseInt(negotiationResult.code),
            headers: {
                ...mockedHeaders,
                ...(negotiationResult.mediaType && { 'Content-type': negotiationResult.mediaType }),
            },
            body: mockedBody,
        };
        logger.success(`Responding with the requested status code ${response.statusCode}`);
        return response;
    })));
}
function isINodeExample(nodeExample) {
    return !!nodeExample && 'value' in nodeExample;
}
function computeMockedHeaders(headers, payloadGenerator) {
    return lodash_1.mapValues(lodash_1.keyBy(headers, h => h.name), header => {
        if (header.schema) {
            if (header.examples && header.examples.length > 0) {
                const example = header.examples[0];
                if (isINodeExample(example)) {
                    return example.value;
                }
            }
            else {
                const example = payloadGenerator(header.schema);
                if (!(lodash_1.isObject(example) && lodash_1.isEmpty(example)))
                    return example;
            }
        }
        return null;
    });
}
function computeBody(negotiationResult, payloadGenerator) {
    if (isINodeExample(negotiationResult.bodyExample) && negotiationResult.bodyExample.value !== undefined) {
        return negotiationResult.bodyExample.value;
    }
    else if (negotiationResult.schema) {
        return payloadGenerator(negotiationResult.schema);
    }
    return undefined;
}
exports.default = mock;

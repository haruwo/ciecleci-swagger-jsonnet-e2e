"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("@stoplight/types");
const Array = require("fp-ts/lib/Array");
const Either = require("fp-ts/lib/Either");
const Option = require("fp-ts/lib/Option");
const pipeable_1 = require("fp-ts/lib/pipeable");
const lodash_1 = require("lodash");
const typeIs = require("type-is");
const deserializers_1 = require("../deserializers");
const utils_1 = require("./utils");
const NonEmptyArray_1 = require("fp-ts/lib/NonEmptyArray");
function deserializeFormBody(schema, encodings, decodedUriParams) {
    if (!schema.properties) {
        return decodedUriParams;
    }
    return pipeable_1.pipe(Object.keys(schema.properties), Array.reduce({}, (deserialized, property) => {
        deserialized[property] = decodedUriParams[property];
        const encoding = encodings.find(enc => enc.property === property);
        if (encoding && encoding.style) {
            const deserializer = deserializers_1.body.get(encoding.style);
            if (deserializer && schema.properties) {
                const propertySchema = schema.properties[property];
                deserialized[property] = deserializer.deserialize(property, decodedUriParams, propertySchema);
            }
        }
        return deserialized;
    }));
}
exports.deserializeFormBody = deserializeFormBody;
function splitUriParams(target) {
    return target.split('&').reduce((result, pair) => {
        const [key, ...rest] = pair.split('=');
        result[key] = rest.join('=');
        return result;
    }, {});
}
exports.splitUriParams = splitUriParams;
function decodeUriEntities(target) {
    return Object.entries(target).reduce((result, [k, v]) => {
        result[decodeURIComponent(k)] = decodeURIComponent(v);
        return result;
    }, {});
}
exports.decodeUriEntities = decodeUriEntities;
function findContentByMediaTypeOrFirst(specs, mediaType) {
    return pipeable_1.pipe(specs, Array.findFirst(spec => spec.mediaType === mediaType), Option.alt(() => Array.head(specs)), Option.map(content => ({ mediaType, content })));
}
exports.findContentByMediaTypeOrFirst = findContentByMediaTypeOrFirst;
function validateBodyIfNotFormEncoded(mediaType, schema, target) {
    return pipeable_1.pipe(mediaType, Option.fromPredicate(mt => !typeIs.is(mt, ['application/x-www-form-urlencoded'])), Option.chain(() => utils_1.validateAgainstSchema(target, schema)));
}
function deserializeAndValidate(content, schema, target) {
    const encodings = lodash_1.get(content, 'encodings', []);
    const encodedUriParams = splitUriParams(target);
    return pipeable_1.pipe(validateAgainstReservedCharacters(encodedUriParams, encodings), Either.map(decodeUriEntities), Either.map(decodedUriEntities => deserializeFormBody(schema, encodings, decodedUriEntities)), Either.fold(e => Option.some(e), deserialised => utils_1.validateAgainstSchema(deserialised, schema)));
}
class HttpBodyValidator {
    constructor(prefix) {
        this.prefix = prefix;
    }
    validate(target, specs, mediaType) {
        const mediaTypeWithContentAndSchema = pipeable_1.pipe(Option.fromNullable(mediaType), Option.chain(mt => findContentByMediaTypeOrFirst(specs, mt)), Option.alt(() => Option.some({ content: specs[0] || {}, mediaType: 'random' })), Option.chain(({ mediaType: mt, content }) => pipeable_1.pipe(Option.fromNullable(content.schema), Option.map(schema => ({ schema, mediaType: mt, content })))));
        return pipeable_1.pipe(mediaTypeWithContentAndSchema, Option.chain(({ content, mediaType: mt, schema }) => pipeable_1.pipe(validateBodyIfNotFormEncoded(mt, schema, target), Option.alt(() => deserializeAndValidate(content, schema, target)), Option.map(diagnostics => applyPrefix(this.prefix, diagnostics)))), Option.chain(NonEmptyArray_1.fromArray), Either.fromOption(() => target), Either.swap);
    }
}
exports.HttpBodyValidator = HttpBodyValidator;
function applyPrefix(prefix, diagnostics) {
    return diagnostics.map(d => ({ ...d, path: [prefix, ...(d.path || [])] }));
}
function validateAgainstReservedCharacters(encodedUriParams, encodings) {
    return pipeable_1.pipe(encodings, Array.reduce([], (diagnostics, encoding) => {
        const allowReserved = lodash_1.get(encoding, 'allowReserved', false);
        const property = encoding.property;
        const value = encodedUriParams[property];
        if (!allowReserved && typeof value === 'string' && /[/?#[\]@!$&'()*+,;=]/.test(value)) {
            diagnostics.push({
                path: [property],
                message: 'Reserved characters used in request body',
                severity: types_1.DiagnosticSeverity.Error,
            });
        }
        return diagnostics;
    }), diagnostics => (diagnostics.length ? Either.left(diagnostics) : Either.right(encodedUriParams)));
}

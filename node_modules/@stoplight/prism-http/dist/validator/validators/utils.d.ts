import { IPrismDiagnostic } from '@stoplight/prism-core';
import { DiagnosticSeverity } from '@stoplight/types';
import { Option } from 'fp-ts/lib/Option';
import * as Ajv from 'ajv';
export declare const convertAjvErrors: (errors: Ajv.ErrorObject[] | null | undefined, severity: DiagnosticSeverity) => (Pick<import("@stoplight/types").IDiagnostic, "tags" | "message" | "severity" | "source" | "code" | "relatedInformation"> & {
    path?: string[] | undefined;
} & {
    path: (string | number)[];
})[];
export declare const validateAgainstSchema: (value: unknown, schema: import("json-schema").JSONSchema4 | import("json-schema").JSONSchema6 | import("json-schema").JSONSchema7, prefix?: string | undefined) => Option<IPrismDiagnostic[]>;
export declare const sequenceValidation: <T extends import("fp-ts/lib/Either").Either<import("fp-ts/lib/NonEmptyArray").NonEmptyArray<IPrismDiagnostic>, any>[]>(...t: T & {
    0: import("fp-ts/lib/Either").Either<import("fp-ts/lib/NonEmptyArray").NonEmptyArray<IPrismDiagnostic>, any>;
}) => import("fp-ts/lib/Either").Either<import("fp-ts/lib/NonEmptyArray").NonEmptyArray<IPrismDiagnostic>, { [K in keyof T]: [T[K]] extends [import("fp-ts/lib/Either").Either<import("fp-ts/lib/NonEmptyArray").NonEmptyArray<IPrismDiagnostic>, infer A>] ? A : never; }>;
export declare const sequenceOption: <T extends Option<any>[]>(...t: T & {
    0: Option<any>;
}) => Option<{ [K in keyof T]: [T[K]] extends [Option<infer A>] ? A : never; }>;

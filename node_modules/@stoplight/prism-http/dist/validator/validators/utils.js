"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("@stoplight/types");
const NonEmptyArray_1 = require("fp-ts/lib/NonEmptyArray");
const Either_1 = require("fp-ts/lib/Either");
const Option_1 = require("fp-ts/lib/Option");
const Apply_1 = require("fp-ts/lib/Apply");
const AjvOAI = require("ajv-oai");
const ajv = new AjvOAI({ allErrors: true, messages: true, schemaId: 'auto' });
exports.convertAjvErrors = (errors, severity) => {
    if (!errors) {
        return [];
    }
    return errors.map(error => {
        const allowedParameters = 'allowedValues' in error.params ? `: ${error.params.allowedValues.join(', ')}` : '';
        return {
            path: error.dataPath.split('.').slice(1),
            code: error.keyword || '',
            message: `${error.message || ''}${allowedParameters}`,
            severity,
        };
    });
};
exports.validateAgainstSchema = (value, schema, prefix) => {
    return Option_1.tryCatch(() => {
        const validate = ajv.compile(schema);
        const valid = validate(value);
        if (!valid) {
            return exports.convertAjvErrors(validate.errors, types_1.DiagnosticSeverity.Error).map(error => {
                const path = prefix ? [prefix, ...error.path] : error.path;
                return Object.assign({}, error, { path });
            });
        }
        return [];
    });
};
exports.sequenceValidation = Apply_1.sequenceT(Either_1.getValidation(NonEmptyArray_1.getSemigroup()));
exports.sequenceOption = Apply_1.sequenceT(Option_1.option);

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("@stoplight/types");
const lodash_1 = require("lodash");
const Either = require("fp-ts/lib/Either");
const Option = require("fp-ts/lib/Option");
const NonEmptyArray_1 = require("fp-ts/lib/NonEmptyArray");
const pipeable_1 = require("fp-ts/lib/pipeable");
const utils_1 = require("./utils");
class HttpParamsValidator {
    constructor(_registry, _prefix, _style) {
        this._registry = _registry;
        this._prefix = _prefix;
        this._style = _style;
    }
    validate(target, specs) {
        const { _registry: registry, _prefix: prefix, _style: style } = this;
        const deprecatedWarnings = specs
            .filter(spec => spec.deprecated && target[spec.name])
            .map(spec => ({
            path: [prefix, spec.name],
            code: 'deprecated',
            message: `${lodash_1.upperFirst(prefix)} param ${spec.name} is deprecated`,
            severity: types_1.DiagnosticSeverity.Warning,
        }));
        const schema = createJsonSchemaFromParams(specs);
        const parameterValues = lodash_1.pickBy(lodash_1.mapValues(lodash_1.keyBy(specs, s => s.name.toLowerCase()), el => {
            const resolvedStyle = el.style || style;
            const deserializer = registry.get(resolvedStyle);
            if (deserializer)
                return deserializer.deserialize(el.name.toLowerCase(), lodash_1.mapKeys(target, (_value, key) => key.toLowerCase()), schema.properties && schema.properties[el.name], el.explode || false);
            return undefined;
        }));
        return pipeable_1.pipe(utils_1.validateAgainstSchema(parameterValues, schema, prefix), Option.map(schemaDiagnostic => schemaDiagnostic.concat(deprecatedWarnings)), Option.chain(NonEmptyArray_1.fromArray), Either.fromOption(() => target), Either.swap);
    }
}
exports.HttpParamsValidator = HttpParamsValidator;
function createJsonSchemaFromParams(params) {
    return {
        type: 'object',
        properties: lodash_1.pickBy(lodash_1.mapValues(lodash_1.keyBy(params, p => p.name.toLowerCase()), 'schema')),
        required: lodash_1.compact(params.map(m => (m.required ? m.name.toLowerCase() : undefined))),
    };
}

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const http_spec_1 = require("@stoplight/http-spec");
const json_ref_readers_1 = require("@stoplight/json-ref-readers");
const json_ref_resolver_1 = require("@stoplight/json-ref-resolver");
const yaml_1 = require("@stoplight/yaml");
const node_fetch_1 = require("node-fetch");
const fs = require("fs");
const lodash_1 = require("lodash");
const os_1 = require("os");
const path_1 = require("path");
const httpAndFileResolver = new json_ref_resolver_1.Resolver({
    resolvers: {
        https: { resolve: json_ref_readers_1.resolveHttp },
        http: { resolve: json_ref_readers_1.resolveHttp },
        file: { resolve: json_ref_readers_1.resolveFile },
    },
    parseResolveResult: opts => Promise.resolve({ ...opts, result: yaml_1.parse(opts.result) }),
});
async function getHttpOperationsFromResource(file) {
    const isRemote = /^https?:\/\//i.test(file);
    const fileContent = isRemote ? await node_fetch_1.default(file).then(d => d.text()) : fs.readFileSync(file, { encoding: 'utf8' });
    return getHttpOperations(fileContent, isRemote ? file : path_1.resolve(file));
}
exports.getHttpOperationsFromResource = getHttpOperationsFromResource;
async function getHttpOperations(specContent, baseUri) {
    const parsedContent = yaml_1.parse(specContent);
    const { result: resolvedContent, errors } = await httpAndFileResolver.resolve(parsedContent, { baseUri });
    if (errors.length) {
        const uniqueErrors = lodash_1.uniq(errors.map(error => error.message)).join(os_1.EOL);
        throw new Error(`There's been an error while trying to resolve external references in your document: ${uniqueErrors}`);
    }
    const isOas2 = lodash_1.get(parsedContent, 'swagger');
    const transformOperationFn = isOas2 ? http_spec_1.transformOas2Operation : http_spec_1.transformOas3Operation;
    const paths = lodash_1.keys(lodash_1.get(resolvedContent, 'paths'));
    const methods = ['get', 'post', 'put', 'delete', 'options', 'head', 'patch', 'trace'];
    return lodash_1.flatten(lodash_1.map(paths, path => lodash_1.keys(lodash_1.get(resolvedContent, ['paths', path]))
        .filter(pathKey => methods.includes(pathKey))
        .map(method => transformOperationFn({
        document: resolvedContent,
        path,
        method,
    }))));
}
exports.default = getHttpOperations;

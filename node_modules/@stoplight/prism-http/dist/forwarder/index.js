"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const node_fetch_1 = require("node-fetch");
const pipeable_1 = require("fp-ts/lib/pipeable");
const Either = require("fp-ts/lib/Either");
const TaskEither = require("fp-ts/lib/TaskEither");
const lodash_1 = require("lodash");
const url_1 = require("url");
const path_1 = require("path");
const parseResponse_1 = require("../utils/parseResponse");
const withLogger_1 = require("../withLogger");
const { version: prismVersion } = require('../../package.json');
const forward = (input, baseUrl) => withLogger_1.default(logger => pipeable_1.pipe(TaskEither.fromEither(serializeBody(input.body)), TaskEither.chain(body => TaskEither.tryCatch(async () => {
    const partialUrl = url_1.parse(baseUrl);
    const url = url_1.format({
        ...partialUrl,
        pathname: path_1.posix.join(partialUrl.pathname || '', input.url.path),
        query: input.url.query,
    });
    logger.info(`Forwarding "${input.method}" request to ${url}...`);
    return node_fetch_1.default(url, {
        body,
        method: input.method,
        headers: lodash_1.defaults(lodash_1.omit(input.headers, ['host', 'accept']), {
            accept: 'application/json, text/plain, */*',
            'user-agent': `Prism/${prismVersion}`,
        }),
    });
}, Either.toError)), TaskEither.chain(parseResponse_1.parseResponse)));
exports.default = forward;
function serializeBody(body) {
    if (typeof body === 'string') {
        return Either.right(body);
    }
    if (body)
        return Either.stringifyJSON(body, Either.toError);
    return Either.right(undefined);
}

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const prism_http_1 = require("@stoplight/prism-http");
const types_1 = require("@stoplight/types");
const fastify = require("fastify");
const fastifyCors = require("fastify-cors");
const typeIs = require("type-is");
const getHttpConfigFromRequest_1 = require("./getHttpConfigFromRequest");
const serialize_1 = require("./serialize");
const pipeable_1 = require("fp-ts/lib/pipeable");
const TaskEither = require("fp-ts/lib/TaskEither");
const Either = require("fp-ts/lib/Either");
exports.createServer = (operations, opts) => {
    const { components, config } = opts;
    const server = fastify({
        logger: components.logger,
        disableRequestLogging: true,
        modifyCoreObjects: false,
    });
    if (opts.cors)
        server.register(fastifyCors, { origin: true, credentials: true });
    server.addContentTypeParser('*', { parseAs: 'string' }, (req, body, done) => {
        if (typeIs(req, ['application/*+json'])) {
            try {
                return done(null, JSON.parse(body));
            }
            catch (e) {
                return done(e);
            }
        }
        if (typeIs(req, ['application/x-www-form-urlencoded'])) {
            return done(null, body);
        }
        const error = new Error(`Unsupported media type.`);
        error.status = 415;
        Error.captureStackTrace(error);
        return done(error);
    });
    const prism = prism_http_1.createInstance(config, components);
    const replyHandler = (request, reply) => {
        const { req: { method, url }, body, headers, query, } = request;
        const input = {
            method: (method ? method.toLowerCase() : 'get'),
            url: {
                path: (url || '/').split('?')[0],
                query,
                baseUrl: query.__server,
            },
            headers,
            body,
        };
        request.log.info({ input }, 'Request received');
        const operationSpecificConfig = getHttpConfigFromRequest_1.getHttpConfigFromRequest(input);
        const mockConfig = opts.config.mock === false ? false : { ...opts.config.mock, ...operationSpecificConfig };
        pipeable_1.pipe(prism.request(input, operations, { ...opts.config, mock: mockConfig }), TaskEither.chain(response => {
            const { output } = response;
            const inputOutputValidationErrors = response.validations.output
                .map(createErrorObjectWithPrefix('response'))
                .concat(response.validations.input.map(createErrorObjectWithPrefix('request')));
            if (inputOutputValidationErrors.length > 0) {
                reply.header('sl-violations', JSON.stringify(inputOutputValidationErrors));
                const errorViolations = inputOutputValidationErrors.filter(v => v.severity === types_1.DiagnosticSeverity[types_1.DiagnosticSeverity.Error]);
                if (opts.errors && errorViolations.length > 0) {
                    return TaskEither.left(prism_http_1.ProblemJsonError.fromTemplate(prism_http_1.VIOLATIONS, 'Your request/response is not valid and the --errors flag is set, so Prism is generating this error for you.', { validation: errorViolations }));
                }
            }
            inputOutputValidationErrors.forEach(validation => {
                const message = `Violation: ${validation.location.join('.') || ''} ${validation.message}`;
                if (validation.severity === types_1.DiagnosticSeverity[types_1.DiagnosticSeverity.Error]) {
                    request.log.error({ name: 'VALIDATOR' }, message);
                }
                else if (validation.severity === types_1.DiagnosticSeverity[types_1.DiagnosticSeverity.Warning]) {
                    request.log.warn({ name: 'VALIDATOR' }, message);
                }
                else {
                    request.log.info({ name: 'VALIDATOR' }, message);
                }
            });
            return TaskEither.fromIOEither(() => Either.tryCatch(() => {
                if (output.headers)
                    reply.headers(output.headers);
                reply
                    .code(output.statusCode)
                    .serializer((payload) => serialize_1.serialize(payload, reply.getHeader('content-type')))
                    .send(output.body);
            }, Either.toError));
        }), TaskEither.mapLeft((e) => {
            if (!reply.sent) {
                const status = e.status || 500;
                reply
                    .type('application/problem+json')
                    .serializer(JSON.stringify)
                    .code(status);
                if (e.additional && e.additional.headers) {
                    reply.headers(e.additional.headers);
                }
                reply.send(prism_http_1.ProblemJsonError.fromPlainError(e));
            }
            else {
                reply.res.end();
            }
            request.log.error({ input }, `Request terminated with error: ${e}`);
        }))();
    };
    opts.cors
        ? server.route({
            url: '*',
            method: ['GET', 'DELETE', 'HEAD', 'PATCH', 'POST', 'PUT'],
            handler: replyHandler,
        })
        : server.all('*', replyHandler);
    const prismServer = {
        get prism() {
            return prism;
        },
        get fastify() {
            return server;
        },
        listen: (port, ...args) => server.listen(port, ...args),
    };
    return prismServer;
};
const createErrorObjectWithPrefix = (locationPrefix) => (detail) => ({
    location: [locationPrefix].concat(detail.path || []),
    severity: types_1.DiagnosticSeverity[detail.severity],
    code: detail.code,
    message: detail.message,
});

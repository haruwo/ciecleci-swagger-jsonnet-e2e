"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const prism_http_1 = require("@stoplight/prism-http");
const types_1 = require("@stoplight/types");
const Either = require("fp-ts/lib/Either");
const pipeable_1 = require("fp-ts/lib/pipeable");
const lodash_1 = require("lodash");
const uri_template_lite_1 = require("uri-template-lite");
function createExamplePath(operation, transformValues = lodash_1.identity) {
    return pipeable_1.pipe(generateTemplateAndValuesForPathParams(operation), Either.chain(({ template: pathTemplate, values: pathValues }) => pipeable_1.pipe(generateTemplateAndValuesForQueryParams(pathTemplate, operation), Either.map(({ template: queryTemplate, values: queryValues }) => {
        return { template: queryTemplate, values: { ...pathValues, ...queryValues } };
    }))), Either.map(({ template, values }) => uri_template_lite_1.URI.expand(template, transformValues(values))));
}
exports.createExamplePath = createExamplePath;
function generateParamValue(spec) {
    return pipeable_1.pipe(prism_http_1.generateHttpParam(spec), Either.fromOption(() => new Error(`Cannot generate value for: ${spec.name}`)), Either.chain(value => {
        switch (spec.style) {
            case types_1.HttpParamStyles.DeepObject:
                return Either.right(prism_http_1.serializeWithDeepObjectStyle(spec.name, value));
            case types_1.HttpParamStyles.PipeDelimited:
                return pipeable_1.pipe(value, Either.fromPredicate(Array.isArray, () => new Error('Pipe delimited style is only applicable to array parameter')), Either.map(v => prism_http_1.serializeWithPipeDelimitedStyle(spec.name, v, spec.explode)));
            case types_1.HttpParamStyles.SpaceDelimited:
                return pipeable_1.pipe(value, Either.fromPredicate(Array.isArray, () => new Error('Space delimited style is only applicable to array parameter')), Either.map(v => prism_http_1.serializeWithSpaceDelimitedStyle(spec.name, v, spec.explode)));
            default:
                return Either.right(value);
        }
    }));
}
function generateParamValues(specs) {
    return specs.reduce((valuesOrError, spec) => pipeable_1.pipe(valuesOrError, Either.chain(values => pipeable_1.pipe(generateParamValue(spec), Either.map(value => ({
        ...values,
        [spec.name]: value,
    }))))), Either.right({}));
}
function generateTemplateAndValuesForPathParams(operation) {
    const specs = lodash_1.get(operation, 'request.path', []);
    return pipeable_1.pipe(generateParamValues(specs), Either.chain(values => pipeable_1.pipe(createPathUriTemplate(operation.path, specs), Either.map(template => ({ template, values })))));
}
function generateTemplateAndValuesForQueryParams(template, operation) {
    const specs = lodash_1.get(operation, 'request.query', []);
    return pipeable_1.pipe(generateParamValues(specs), Either.map(values => ({ template: createQueryUriTemplate(template, specs), values })));
}
function createPathUriTemplate(inputPath, specs) {
    return specs
        .filter(spec => spec.required !== false)
        .reduce((pathOrError, spec) => pipeable_1.pipe(pathOrError, Either.chain(path => pipeable_1.pipe(createParamUriTemplate(spec.name, spec.style || types_1.HttpParamStyles.Simple, spec.explode || false), Either.map(template => path.replace(`{${spec.name}}`, template))))), Either.right(inputPath));
}
function createParamUriTemplate(name, style, explode) {
    const starOrVoid = explode ? '*' : '';
    switch (style) {
        case types_1.HttpParamStyles.Simple:
            return Either.right(`{${name}${starOrVoid}}`);
        case types_1.HttpParamStyles.Label:
            return Either.right(`{.${name}${starOrVoid}}`);
        case types_1.HttpParamStyles.Matrix:
            return Either.right(`{;${name}${starOrVoid}}`);
        default:
            return Either.left(new Error(`Unsupported parameter style: ${style}`));
    }
}
function createQueryUriTemplate(path, specs) {
    const formSpecs = specs.filter(spec => (spec.style || types_1.HttpParamStyles.Form) === types_1.HttpParamStyles.Form);
    const formExplodedParams = formSpecs
        .filter(spec => spec.required !== false)
        .filter(spec => spec.explode)
        .map(spec => spec.name)
        .join(',');
    const formImplodedParams = formSpecs
        .filter(spec => spec.required !== false)
        .filter(spec => !spec.explode)
        .map(spec => spec.name)
        .join(',');
    const restParams = specs
        .filter(spec => spec.required !== false)
        .filter(spec => [types_1.HttpParamStyles.DeepObject, types_1.HttpParamStyles.SpaceDelimited, types_1.HttpParamStyles.PipeDelimited].includes(spec.style))
        .map(spec => spec.name)
        .map(name => `{+${name}}`)
        .join('&');
    if (formExplodedParams) {
        path += `{?${formExplodedParams}*}`;
    }
    if (formImplodedParams) {
        path += `{${formExplodedParams ? '&' : '?'}${formImplodedParams}}`;
    }
    if (restParams) {
        path += `${formExplodedParams || formImplodedParams ? '&' : '?'}${restParams}`;
    }
    return path;
}

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Either = require("fp-ts/lib/Either");
const Option = require("fp-ts/lib/Option");
const pipeable_1 = require("fp-ts/lib/pipeable");
const TaskEither = require("fp-ts/lib/TaskEither");
const lodash_1 = require("lodash");
const Apply_1 = require("fp-ts/lib/Apply");
const NonEmptyArray_1 = require("fp-ts/lib/NonEmptyArray");
const types_1 = require("@stoplight/types");
const sequenceValidation = Apply_1.sequenceT(Either.getValidation(NonEmptyArray_1.getSemigroup()));
function isProxyConfig(p) {
    return !p.mock;
}
function factory(defaultConfig, components) {
    const inputValidation = (resource, input, config) => pipeable_1.pipe(sequenceValidation(config.validateRequest ? components.validateInput({ resource, element: input }) : Either.right(input), config.checkSecurity ? components.validateSecurity({ resource, element: input }) : Either.right(input)), Either.fold(validations => validations, () => []), validations => TaskEither.right({ resource, validations }));
    const mockOrForward = (resource, input, config, validations) => {
        const produceOutput = isProxyConfig(config)
            ? components.forward(input, config.upstream.href)(components.logger.child({ name: 'PROXY' }))
            : TaskEither.fromEither(components.mock({
                resource,
                input: {
                    validations,
                    data: input,
                },
                config: config.mock,
            })(components.logger.child({ name: 'NEGOTIATOR' })));
        return pipeable_1.pipe(produceOutput, TaskEither.map(output => ({ output, resource, validations })));
    };
    return {
        request: (input, resources, c) => {
            const config = lodash_1.defaults(c, defaultConfig);
            return pipeable_1.pipe(TaskEither.fromEither(components.route({ resources, input })), TaskEither.fold(error => {
                if (!config.errors && isProxyConfig(config)) {
                    return pipeable_1.pipe(components.forward(input, config.upstream.href)(components.logger.child({ name: 'PROXY' })), TaskEither.map(output => ({
                        input,
                        output,
                        validations: {
                            input: [
                                {
                                    message: "The selected route hasn't been found and the errors is set false. Prism has proxied the request to the upstream server but no validation will happen",
                                    severity: types_1.DiagnosticSeverity.Warning,
                                },
                            ],
                            output: [],
                        },
                    })));
                }
                else
                    return TaskEither.left(error);
            }, resource => pipeable_1.pipe(inputValidation(resource, input, config), TaskEither.chain(({ resource, validations }) => mockOrForward(resource, input, config, validations)), TaskEither.map(({ output, resource, validations: inputValidations }) => {
                const outputValidations = config.validateResponse
                    ? pipeable_1.pipe(Option.fromEither(Either.swap(components.validateOutput({ resource, element: output }))), Option.getOrElse(() => []))
                    : [];
                return {
                    input,
                    output,
                    validations: {
                        input: inputValidations,
                        output: outputValidations,
                    },
                };
            }))));
        },
    };
}
exports.factory = factory;
